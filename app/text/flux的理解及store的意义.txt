facebook对于flux的说明，重点为复用性，流动性。复用性体现在优化性能上，而流动性，出于数据可预测，体现在维护上。  
      在这里不会说明FLUX的实现方式，网上已经有很多优秀的说明文，此处我会重点讨论Flux什么时候该使用。
      所以以下会以两个方面展开：
           1.我对项目构建的思考
           2.flxu的正确打开方式
      起始我对该项目构建思考了好久，首先既然强调复用性，那么就应该从各组件之间不变的地方来看。
      最后发现事实上可以从数据的角度来思考，而不应该从数据的提取方式来思考，我将数据划分为以下3个部分：
           1.静态数据
           2.动静态数据
           3.动态数据
      1，2两者共同点在于他们的数据无需ajax去请求，它开始就已经被设定好，不同点在于，
      1构建组件时不用传入参数（ps：任何组件渲染，都是通过函数的，基于可复用及维护）。
      2构建组件是需要传入参数，传入的参数帮助筛选那部分数据需要渲染，但是这些数据都不是存储在数据库中的，在加载构建组件是它本身就在里面。
      3不同于前两点在于它的数据都是存储在后端数据库中需请求的。
    整个结构中就这3种类型的数据，接下来讨论如何渲染这些数据：
    其实就两步 ：
        1.对于静态数据渲染：
               step1 直接渲染组件（因为前面说的该部分组件数据不可变，同时无需和其他组件共享，直接将这部分数据存储到组件中）
        2.对于动静态数据渲染：
               step1：getdata（chooes），通过传入的参数进行筛选，那部分数据需要取出来，所以这部分数据存储在getdata这样类型的函数中。
               step2：set（data），通过上一步获取的数据，渲染
        3.对于动态数据渲染：
               step1：getdata（），通过请求后端数据库数据，同时返回数据，此处设计是每一需要动态数据的组件获取数据的方式是通过不同得函数获取，无需传入参数。  
               step2：set（data），同理获取上一步的数据同时渲染。
     最后总结发现，渲染数据就两步  step1:获取数据，step2：渲染数据
     两步中暴露两个类型api，方便后面页面切换时调用。
     数据渲染思考完了，开始思考交互中ui切换。
     此处应有“Flux”切换步骤如下：
                1 切换发起（如某些按钮被点击）
                2 action被执行，将要显示的ui层id传入store
                3 store中通过传入得到的id。switch选入要渲染的ui层，并通过数据渲染中暴露的接口进行渲染。
     这样是不是很完美，ok现在该开始执行它了，但总感觉似曾相识啊，是的我还没执行就发现，我居然把一个好好的Flux写成了MVC模式，想想我们前面说的，Flux构建程序，复用性，流动性，好像我写的没有一个满足。。。。将store写成了一个control层，用于控制切换，control写到后面随着功能页面的增多，肯定会越来越臃肿，什么东西都往里面塞，难以维护
      说了这么多错误用法，作为错误的典型还是很成功的。
      不说废话了，于是我开始思考基于Flux的构建方式
      既然要构建Flux就要理解它，网上有很多这个方面的优秀文章，但是大多讲解的都是如何构建，没有讲解为什么这样构建，此处讨论的就是这一点。为什么基于Flux构建，Facebook说基于Flux构建的web结构，具有流动性，和复用性，
      首先我们分析流动性如何做到的以及为什么要具有流动性，在Facebook官方给的例子中，流动性可以做到数据的可预测从而稳定，那就是获取数据的API接口，获取数据通过ACTION传入Stroe中，这样的数据具有单向流动性，当然还有的基于Flux的框架Redux不是这样做的，它的store中有获取数据的功能，个人感觉是不对，这样store到后面会变得臃肿，数据也变得不可预测，丧失了本身构建它初衷。
       然后复用性，我认为store应该是一个前端的数据库，action将数据传入到里面，各个需要它的组件从中订阅，取出数据。
      ok，那么我就想好了一个真正基于Flux的构建方式
      数据还是哪三种，静态，动静态，动态数据。
      对于后两种，采用的模式为：
                  step1：获取数据
                  step2：数据放入store中
                  step3：渲染store中的数据
      然后我就开始了痛苦的实践，思路上很清晰，但是没写多久，没个组件都对应着一个store，同时还要附加action，getdata，虽然逻辑上很清晰，但是后面越来越多，我就是开始思考这是Flux的用法吗？
      看到阮一峰老师的一句话，当你不知道该不该使用Flux的时候就不去用它，对于小项目只会增加项目的复杂性。
      是的，我就是太想用它，而不是适用它，然后我发现，我的Flux实现了流动性，但是没有实用复用性，复用性才是提高性能的属性。
      最后我创建了一个我觉得最适合当前项目的构建方式，它有一下几个原则：
             1.真正放入store中的数据应该是可复用的数据，同时该数据也应该是ajax获得的。
             2.构建是我将Control，对应到每个容器当中，因为SPA中，容器数量是不变的，或者说每个组件挂载时，他的目标挂载对象是不变的，那么control放入这里就非常适合了，它负责控制哪个组件现在挂载上去，筛选的方式通过其他触发ui传入的参数。这样做的好处在于当将来要添加新的功能组件时，只需要去它的挂载control注册就ok了，
             3.不应该以数据的获取方式来划分，而是通过数据是否复用来划分。
      总结下渲染方式：
         1. 对于没有通过AJAX请求得到的数据，切没有其他组件不会使用这部分数据，直接将数据存储到组件的构建方法中，渲染时直接渲染。
         2. 对于没有通过AJAX请求得到的数据,但是该部分数据别的组件中需要使用，那么将该数据放入store中，同时这种store不对外暴露更改接口，即该部分数据属于不可变的。渲染时组件从store中取出数据，需要筛选则传入参数。（此处的store和Flux中的Store不同）
         3. 对于通过ajax请求得到的数据，但是该部分数据不可复用，即只有该组件使用它，那么获取数据吼直接渲染。
         4.对于通过Ajax请求得到的数据，切其他组件需要使用，则存入store中，需要时各组件取出该数据。 （此处的store属于一种缓存方式）     